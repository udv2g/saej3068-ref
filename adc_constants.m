% This Matlab script generates a header file of macros to define maximum and minimum ADC count values for the various Pilot and Prox states.
% It has been tested to work correctly in Octave.  It calculates the values based on the resistor network used to attenuate and shift 
% the Pilot signal, and the Prox resistor network defined in section 6.2 of J3068 (Ed. 1).

clear all;

HeaderFile = 'adc_constants.h';
FilePath = 'Project/Sources/';

%All
global Vsup = 5;                %Supply voltage of ADC
global Bits = 8;                %ADC resolution
global Type = @uint8;           %smallest standard type the ADC resolution fits in

%Pilot
global Rsup = 62e3;             %Resistor between the supply and ADC input
global Rgnd = 91e3;             %Resistor between the ADC input and ground
global Rseries = 200e3;         %Resistor between the Pilot signal and the ADC input


StateANominal = 12;
StateAPlus = StateAMinus = 1;   %Emperical additive tolerance on Pilot state values
StateBNominal = 9;
StateBPlus = StateBMinus = 1;
StateCNominal = 6;
StateCPlus = StateCMinus = 1.3;
StateENominal = 0;
StateEPlus = StateEMinus = 1.2;
StateFNominal = -12;
StateFPlus = 1;
StateFMinus = 1.2;
%These are not used in J3068
StateDNominal = 3;
StateDPlus = StateDMinus = 1;
StateRNominal = -5.3;
StateRPlus = StateRMinus = 1;


%Prox
global J1772ResTol = 10;        %Tolerance (%) of resistors in the standard/J1772 Prox circuit
J1772ExtraTol = 15;             %Tolerance (%) on computed value (power supply, etc.)

IECResTol = 3;                  %Tolerance (%) of resistors in the J3068/61581-Annex-D Prox Circuit

global FileHandle = fopen([FilePath HeaderFile],'w');

function Vout = DividerVoltage( Vin )
	global Vsup Rsup Rgnd Rseries 
	Vout = (Rsup*Rgnd*Vin + Rseries*Rgnd*Vsup)/(Rsup*Rgnd + Rseries*Rgnd + Rseries*Rsup);
end

function Counts = ADCcounts( Vin )
	global Vsup Bits Type 
	Counts = Type( (Vin/Vsup) * (2^Bits - 1));
end

function out = ConstCalc( Vin )
	out = ADCcounts(DividerVoltage(Vin));
end

function _DefinePilot( State, Limit, Voltage)
	global FileHandle
	
	fprintf(FileHandle, '#define %-35s 0x%02X     // %d V\n', ['STATE_' State, '_', Limit], ConstCalc(Voltage), Voltage)
end

function DefinePilot( State, Nom, Plus, Minus)
	global FileHandle
	
	_DefinePilot(State, 'MAX', Nom+Plus)
	_DefinePilot(State, 'NOM', Nom)
	_DefinePilot(State, 'MIN', Nom-Minus)
	fprintf(FileHandle, '\n');
end

function R = par( r1, r2 )
	R = r1*r2/(r1+r2);
end


function V = ProxV( r6, tolerance,  dir, J1772)	%tolerance in percent, dir is boolean true skews high
	global J1772ResTol
	int_J1772ResTol = J1772ResTol/100;

	tolerance = tolerance/100;
	low = 1-tolerance;
	high = 1+tolerance;
	if dir
		pos = high;
		neg = low;
	else
		pos = low;
		neg = high;
	end
	r4 = neg*330;
	r5 = pos*2700;
	if J1772
		if dir
			r6 = (1+int_J1772ResTol)*r6;
		else
			r6 = (1-int_J1772ResTol)*r6;
		end
	else
		r6 = pos*r6;
	end
	rl = par(r5, r6);
	V = (rl/(r4+rl));
end

function __DefineProx( Ident, Limit, Value )
	global FileHandle Bits Vsup

	fprintf(FileHandle, '#define %-35s 0x%02X     // %d V\n', [Ident, '_', Limit], Value , (double(Value)/(2^Bits -1))*Vsup)
end

function _DefineProx( Ident, min, max )
	global FileHandle
	
	__DefineProx( Ident, 'MAX', max )
	__DefineProx( Ident, 'MIN', min )
	fprintf(FileHandle, '\n')
end

function DefineProx( Ident, r6, tolerance, J1772, ExtraTol)	
	global Bits Type
	
	ExtraTol = ExtraTol/100;
	lowP = 1-ExtraTol;
	highP = 1+ExtraTol;
	
	high = ProxV( r6, tolerance, true, J1772)*highP;
	low = ProxV( r6, tolerance, false, J1772)*lowP;
	
	_DefineProx( Ident, Type( low * (2^Bits -1) ), Type( high * (2^Bits -1) ) )
end

function out = SplitDiff( Low, High )
	out = Low + ((High - Low) / 2);
end

GuardString = upper(HeaderFile);
GuardString(end-1) = '_';
GuardString = ['_' GuardString];

%header guard
fprintf(FileHandle, ['#ifndef ' GuardString '\n'] );
fprintf(FileHandle, ['#define ' GuardString '\n'] );

fprintf(FileHandle, '\n// This file is generated by adc_constants.m \n\n');

% Pilot section
% States D and R are not used in J3068
fprintf(FileHandle, '\n// MIN/MAX Values for the Pilot states\n');
DefinePilot('A', StateANominal, StateAPlus, StateAMinus);
DefinePilot('B', StateBNominal, StateBPlus, StateBMinus);
DefinePilot('C', StateCNominal, StateCPlus, StateCMinus);
DefinePilot('D', StateDNominal, StateDPlus, StateDMinus);
DefinePilot('E', StateENominal, StateEPlus, StateEMinus);
DefinePilot('R', StateRNominal, StateRPlus, StateRMinus);
DefinePilot('F', StateFNominal, StateFPlus, StateFMinus);

% Prox section
% Nominal values are not generated as they aren't used.
fprintf(FileHandle, '\n// MIN/MAX Values for the Prox states\n');
fprintf(FileHandle, '// Standard prox is not used in J3068, but the code is capable of handling it so we might as well define the values.\n')

DefineProx( 'PROX_STATE_DISCONNECTED', 100000000000000000, J1772ResTol, false, J1772ExtraTol)  %Use a very large value for "infinite" R6 A.K.A. disconnected
DefineProx( 'PROX_STATE_CONNECTED_OFF', 150+330, J1772ResTol, false, J1772ExtraTol)
DefineProx( 'PROX_STATE_CONNECTED_ON', 150, J1772ResTol, false, J1772ExtraTol)
fprintf(FileHandle, '\n')

fprintf(FileHandle, '// J3068/61581-Annex-D Prox\n')
% Calculate nominal fraction of power supply of the edges of each state
IECDisconnectedMaxRaw = ProxV(100000000000000000, IECResTol, true, false);
IECDisconnectedMinRaw = ProxV(100000000000000000, IECResTol, false, false);
IECReservedHighMaxRaw = ProxV(3520, IECResTol, true, false);
IECReservedHighMinRaw = ProxV(3300, IECResTol, false, false);
IEC13AMaxRaw = ProxV(1500, IECResTol, true, false);
IEC13AMinRaw = ProxV(1500, IECResTol, false, false);
IEC20AMaxRaw = ProxV(680, IECResTol, true, false);
IEC20AMinRaw = ProxV(680, IECResTol, false, false);
IECReservedButtonDownMaxRaw = ProxV(150+330, IECResTol, true, true);
IECReservedButtonDownMinRaw = ProxV(150+330, IECResTol, false, true);
IEC32AMaxRaw = ProxV(220, IECResTol, true, false);
IEC32AMinRaw = ProxV(220, IECResTol, false, false);
IECReservedButtonUpMaxRaw = ProxV(150, IECResTol, true, true);
IECReservedButtonUpMinRaw = ProxV(150, IECResTol, false, true);
IEC63AMaxRaw = ProxV(100, IECResTol, true, false)*1.1;   %extra tolerance for noisiest state.  if modified, check it does not overlap adjacent.
IEC63AMinRaw = ProxV(100, IECResTol, false, false)*.9;
IECReservedLowMaxRaw = ProxV( par(3520, 68), IECResTol, true, false);
IECReservedLowMinRaw = ProxV( par(100, 68), IECResTol, false, false);

% Find the point between adjacent vlaues calculated in the previous step
IECDisconnectedErrorHigh = SplitDiff(IECDisconnectedMaxRaw, 1);
IECReservedHighDisconnected = SplitDiff(IECReservedHighMaxRaw, IECDisconnectedMinRaw);
IEC13AReservedHigh = SplitDiff(IEC13AMaxRaw, IECReservedHighMinRaw);
IEC20A13A = SplitDiff(IEC20AMaxRaw, IEC13AMinRaw);
IECReservedButtonDown20A = SplitDiff(IECReservedButtonDownMaxRaw, IEC20AMinRaw);
IEC32AReservedButtonDown = SplitDiff(IEC32AMaxRaw, IECReservedButtonDownMinRaw);
IECReservedButtonUp32A = SplitDiff(IECReservedButtonUpMaxRaw, IEC32AMinRaw);
IEC63AReservedButtonUp = SplitDiff(IEC63AMaxRaw, IECReservedButtonUpMinRaw);
IECReservedLow63A = SplitDiff(IECReservedLowMaxRaw, IEC63AMinRaw);
IECErrorLowReservedLow = SplitDiff(0, IECReservedLowMinRaw);

% Calculate counts associated with the last calculation and define the states so they don't overlap
IECErrorHighMin = Type( IECDisconnectedErrorHigh * (2^Bits -1) );
IECDisconnectedMax = IECErrorHighMin - 1;
IECDisconnectedMin = Type( IECReservedHighDisconnected * (2^Bits -1) );
IECReservedHighMax = IECDisconnectedMin - 1;
IECReservedHighMin = Type( IEC13AReservedHigh * (2^Bits -1) );
IEC13AMax = IECReservedHighMin - 1;
IEC13AMin = Type( IEC20A13A * (2^Bits -1) );
IEC20AMax = IEC13AMin - 1;
IEC20AMin = Type( IECReservedButtonDown20A * (2^Bits -1) );
IECReservedButtonDownMax = IEC20AMin - 1;
IECReservedButtonDownMin = Type( IEC32AReservedButtonDown * (2^Bits -1) );
IEC32AMax = IECReservedButtonDownMin - 1;
IEC32AMin = Type( IECReservedButtonUp32A * (2^Bits -1) );
IECReservedButtonUpMax = IEC32AMin - 1;
IECReservedButtonUpMin = Type( IEC63AReservedButtonUp * (2^Bits -1) );
IEC63AMax = IECReservedButtonUpMin - 1;
IEC63AMin = Type( IECReservedLow63A * (2^Bits -1) );
IECReservedLowMax = IEC63AMin - 1;
IECReservedLowMin = Type( IECErrorLowReservedLow * (2^Bits -1) );
IECErrorLowMax = IECReservedLowMin - 1;

% Print values to file
__DefineProx( 'IEC_PROX_ERROR_HIGH', 'MIN', IECErrorHighMin)
fprintf(FileHandle, '\n')
_DefineProx( 'IEC_PROX_DISCONNECTED', IECDisconnectedMin, IECDisconnectedMax)
_DefineProx( 'IEC_PROX_RESERVED_HIGH', IECReservedHighMin, IECReservedHighMax)
_DefineProx( 'IEC_PROX_13A', IEC13AMin, IEC13AMax)
_DefineProx( 'IEC_PROX_20A', IEC20AMin, IEC20AMax)
_DefineProx( 'IEC_PROX_RESERVED_BUTTON_DOWN', IECReservedButtonDownMin, IECReservedButtonDownMax)
_DefineProx( 'IEC_PROX_32A', IEC32AMin, IEC32AMax)
_DefineProx( 'IEC_PROX_RESERVED_BUTTON_UP', IECReservedButtonUpMin, IECReservedButtonUpMax)
_DefineProx( 'IEC_PROX_63A', IEC63AMin, IEC63AMax)
_DefineProx( 'IEC_PROX_RESERVED_LOW', IECReservedLowMin, IECReservedLowMax)
__DefineProx( 'IEC_PROX_ERROR_LOW', 'MAX', IECErrorLowMax)

fprintf(FileHandle, '\n\n#endif\n' );

fclose('all');


